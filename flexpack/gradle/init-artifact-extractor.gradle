import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.ivy.IvyPublication
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.tasks.*
import org.gradle.work.DisableCachingByDefault
import groovy.json.JsonOutput
import java.security.MessageDigest
import java.nio.file.Files
import java.nio.file.StandardCopyOption

// ==============================================================================
// 1. DATA MODEL
// ==============================================================================
class ArtifactData implements Serializable {
    @Internal
    File file

    @Input
    String destName

    @Input
    String repoPath

    @Input
    String type

    @Input
    String moduleName
    
    String toString() { return "${moduleName}::${repoPath}::${destName}" }
}

// ==============================================================================
// 2. CUSTOM TASK
// ==============================================================================
@CacheableTask
abstract class CiManifestTask extends DefaultTask {

    @Nested
    abstract ListProperty<ArtifactData> getArtifactData()

    @InputFiles
    @PathSensitive(PathSensitivity.NONE) 
    abstract ConfigurableFileCollection getInputFiles()

    @Input
    abstract Property<Boolean> getShouldHash()

    @OutputFile
    abstract RegularFileProperty getManifestFile()

    @TaskAction
    void generate() {
        def outputFile = manifestFile.get().asFile
        
        // 1. Create Temp File (Manual cleanup as requested)
        def tempFile = File.createTempFile("manifest-", ".tmp", outputFile.parentFile)
        
        def hashesEnabled = shouldHash.get()
        def results = []
        
        // Retrieve list once
        def artifacts = getArtifactData().get()

        artifacts.each { item ->
            File file = item.file
            
            if (file && file.exists() && file.isFile()) {
                
                def hashes = hashesEnabled ? computeHashes(file) : [sha1: null, sha256: null, md5: null]
                
                results << [
                    module_name: item.moduleName,
                    type: item.type,
                    name: item.destName,
                    path: item.repoPath,
                    sha1: hashes.sha1,
                    sha256: hashes.sha256,
                    md5: hashes.md5
                ]

                // Manual check for detached signatures (.asc)
                File ascFile = new File(file.absolutePath + ".asc")
                if (ascFile.exists() && ascFile.isFile()) {
                    def ascHashes = hashesEnabled ? computeHashes(ascFile) : [sha1: null, sha256: null, md5: null]
                    results << [
                        module_name: item.moduleName,
                        type: "${item.type}.asc",
                        name: "${item.destName}.asc",
                        path: "${item.repoPath}.asc",
                        sha1: ascHashes.sha1,
                        sha256: ascHashes.sha256,
                        md5: ascHashes.md5
                    ]
                }
            }
        }

        if (!results.isEmpty()) {
            // Dedupe using path AND type to handle collisions
            results = results.unique { "${it.path}::${it.type}" }
                             .sort { a, b -> a.path <=> b.path }

            // 2. Write Compact JSON (No prettyPrint)
            tempFile.text = JsonOutput.toJson(results)
            
            // 3. Atomic Move
            Files.move(tempFile.toPath(), outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
            
            logger.lifecycle("[CI-Manifest] Generated at: ${outputFile.absolutePath}")
        }
    }

    Map computeHashes(File file) {
        try {
            def md5 = MessageDigest.getInstance("MD5")
            def sha1 = MessageDigest.getInstance("SHA-1")
            def sha256 = MessageDigest.getInstance("SHA-256")

            file.withInputStream { is ->
                byte[] buffer = new byte[8192]
                int read
                while ((read = is.read(buffer)) != -1) {
                    md5.update(buffer, 0, read)
                    sha1.update(buffer, 0, read)
                    sha256.update(buffer, 0, read)
                }
            }
            return [
                sha1: toHex(sha1.digest()),
                sha256: toHex(sha256.digest()),
                md5: toHex(md5.digest())
            ]
        } catch (Exception e) {
            logger.warn("[CI-Manifest] Failed to compute hash for ${file.name}", e)
            return [sha1: null, sha256: null, md5: null]
        }
    }

    String toHex(byte[] bytes) {
        return bytes.collect { String.format("%02x", it & 0xff) }.join()
    }
}

// ==============================================================================
// 3. WIRING
// ==============================================================================

gradle.rootProject {
    tasks.register("generateCiManifest", CiManifestTask) { t ->
        t.group = "reporting"
        t.description = "Generates a JSON manifest of all published artifacts"
        t.manifestFile.set(layout.buildDirectory.file("ci-artifacts-manifest.json"))
        
        def skipProp = gradle.startParameter.projectProperties['ciInspector.skipHash'] ?: "false"
        t.shouldHash.set(!skipProp.toBoolean())
    }
}

allprojects { project ->
    project.plugins.withType(PublishingPlugin) {
        
        def rootManifestTask = project.rootProject.tasks.named("generateCiManifest", CiManifestTask)

        // afterEvaluate is legacy but necessary for robust Gradle 5/6 compatibility
        project.afterEvaluate {
            def publishing = project.extensions.findByType(PublishingExtension)
            if (!publishing) return

            // 1. Prepare Collections
            def dataList = []
            def dependencyTracker = project.objects.fileCollection()

            collectArtifacts(project, publishing, dataList, dependencyTracker)

            // 2. Wrap Data in Provider
            def dataProvider = project.provider { dataList }

            // 3. Configure Root Task
            rootManifestTask.configure { t ->
                // Must use addAll here because we are aggregating from multiple projects.
                // 'set' would overwrite previous projects' data.
                t.getArtifactData().addAll(dataProvider)
                
                t.getInputFiles().from(dependencyTracker)
                
                // Use shouldRunAfter to allow manifest generation even if publishing is skipped
                t.shouldRunAfter(project.tasks.withType(PublishToMavenRepository))
                t.shouldRunAfter(project.tasks.withType(PublishToIvyRepository))
            }
        }
    }
}

// Helper
void collectArtifacts(Project project, PublishingExtension publishing, List list, ConfigurableFileCollection fileTracker) {
    
    def projectPath = project.path 

    publishing.publications.all { publication ->
        def coords = [:]
        def isMaven = (publication instanceof MavenPublication)
        def isIvy = (publication instanceof IvyPublication)

        if (isMaven) {
            if (!publication.groupId || !publication.artifactId || !publication.version) return
            coords = [g: publication.groupId, a: publication.artifactId, v: publication.version]
        } else if (isIvy) {
            if (!publication.organisation || !publication.module || !publication.revision) return
            coords = [o: publication.organisation, m: publication.module, r: publication.revision]
        }

        def getRepoPath = { name ->
            if (isMaven) return "${coords.g.replace('.','/')}/${coords.a}/${coords.v}/${name}"
            else return "${coords.o}/${coords.m}/${coords.r}/${name}"
        }

        def track = { Object rawFile, String name, String type, Object buildDependency ->
            if (rawFile) {
                // Gradle 5 vs 6+ compatibility check for Provider<RegularFile> vs File
                File f
                if (rawFile instanceof Provider) {
                    f = rawFile.get().asFile
                } else if (rawFile instanceof File) {
                    f = rawFile
                } else {
                    return // Unknown type, skip
                }

                def d = new ArtifactData()
                d.file = f
                d.destName = name
                d.repoPath = getRepoPath(name)
                d.type = type
                d.moduleName = projectPath
                list.add(d)

                fileTracker.from(f)
                
                if (buildDependency) {
                    fileTracker.builtBy(buildDependency)
                }
            }
        }

        // A. Artifacts
        publication.artifacts.each { artifact ->
            def ext = artifact.extension ?: "jar"
            def classifier = artifact.classifier ?: ""
            
            def destName = ""
            if (isMaven) destName = "${coords.a}-${coords.v}${classifier ? '-' + classifier : ''}.${ext}"
            else destName = "${coords.m}-${coords.r}${classifier ? '-' + classifier : ''}.${ext}"
            
            track(artifact.file, destName, ext, artifact)
        }

        // B. Metadata (Maven)
        if (isMaven) {
            def pomName = "${coords.a}-${coords.v}.pom"
            def pomTask = project.tasks.findByName("generatePomFileFor${publication.name.capitalize()}Publication")
            if (pomTask) track(pomTask.outputs.files.singleFile, pomName, "pom", pomTask)

            def moduleName = "${coords.a}-${coords.v}.module"
            def metaTask = project.tasks.findByName("generateMetadataFileFor${publication.name.capitalize()}Publication")
            if (metaTask && metaTask.enabled) track(metaTask.outputs.files.singleFile, moduleName, "module", metaTask)
        }

        // C. Metadata (Ivy)
        if (isIvy) {
            def ivyName = "ivy-${coords.r}.xml"
            def ivyTask = project.tasks.findByName("generateDescriptorFileFor${publication.name.capitalize()}Publication")
            if (ivyTask) track(ivyTask.outputs.files.singleFile, ivyName, "ivy", ivyTask)
        }
    }
}