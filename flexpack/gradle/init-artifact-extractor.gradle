 import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.ListProperty
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.ivy.IvyPublication
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.tasks.*
import groovy.json.JsonOutput
import java.security.MessageDigest
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import java.nio.charset.StandardCharsets
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ForkJoinPool
import java.util.concurrent.atomic.AtomicBoolean
import java.time.Instant

// ==============================================================================
// 1. DATA MODEL
// ==============================================================================

class ArtifactData implements Serializable {
    File file
    String destName
    String repoPath
    String type
    String moduleName

    transient Object builtBy
}

// ==============================================================================
// 2. CUSTOM TASK
// ==============================================================================

@CacheableTask
abstract class CiManifestTask extends DefaultTask {

    // --- Configuration Constants ---
    private static final int BUFFER_SIZE = 8192 // 8KB is standard for IO buffers
    private final Object logLock = new Object() // Safe mutex for file writing

    // --- Task Inputs/Outputs ---

    // Internal source of truth (Synchronized List for thread safety during configuration)
    protected List<ArtifactData> artifacts = Collections.synchronizedList([])

    @Internal
    List<ArtifactData> getArtifacts() {
        return artifacts
    }

    // 1. Track File Content Changes
    private ConfigurableFileCollection _inputFiles

    @InputFiles
    @PathSensitive(PathSensitivity.NONE)
    ConfigurableFileCollection getInputFiles() {
        if (_inputFiles == null) {
            _inputFiles = project.files()
        }
        return _inputFiles
    }

    // 2. Track Metadata Changes
    @Input
    String getArtifactMetadata() {
        // Sort for cache key stability
        def sorted = artifacts.collect {
            [m: it.moduleName, p: it.repoPath, n: it.destName, t: it.type]
        }.sort { a, b -> a.p <=> b.p }
        return JsonOutput.toJson(sorted)
    }

    @Input
    abstract Property<Boolean> getShouldHash()

    @Input
    @Optional
    abstract Property<Boolean> getFollowSymlinks()

    @Input
    @Optional
    abstract Property<Boolean> getFailOnBrokenSymlinks()

    @Input
    @Optional
    abstract ListProperty<String> getIncludeModules()

    @Input
    @Optional
    abstract Property<Boolean> getFailOnHashError()

    @OutputFile
    abstract RegularFileProperty getManifestFile()

    @OutputFile
    abstract RegularFileProperty getFailureLogFile()

    void addArtifact(ArtifactData data) {
        if (!data.file) return
        this.artifacts.add(data)

        def fileEntry = this.getInputFiles().from(data.file)
        if (data.builtBy instanceof TaskDependency) {
            fileEntry.builtBy(data.builtBy)
        } else if (data.builtBy) {
            fileEntry.builtBy(data.builtBy)
        }
    }

    @TaskAction
    void generate() {
        File outputFile = manifestFile.get().asFile
        File errorLog = failureLogFile.get().asFile

        // Clean previous outputs to ensure clean state
        if (outputFile.exists()) outputFile.delete()
        if (errorLog.exists()) errorLog.delete()
        
        outputFile.parentFile.mkdirs()

        // Capture settings
        def hashesEnabled = shouldHash.get()
        def followSymlinksVal = followSymlinks.getOrElse(false)
        def failBrokenSymlinks = failOnBrokenSymlinks.getOrElse(true)
        def failHashError = failOnHashError.getOrElse(false)
        def includedModulesVal = includeModules.getOrElse([])

        // 1. Snapshot & Sort (Determinism)
        List<ArtifactData> sortedArtifacts
        synchronized(this.artifacts) {
            sortedArtifacts = new ArrayList<>(this.artifacts)
        }

        // Deep sort for absolute reproducibility
        sortedArtifacts.sort { a, b ->
            def p = a.repoPath <=> b.repoPath
            if (p != 0) return p
            def t = a.type <=> b.type
            if (t != 0) return t
            def n = a.destName <=> b.destName
            if (n != 0) return n
            return a.moduleName <=> b.moduleName
        }

        // 2. Filter
        if (!includedModulesVal.isEmpty()) {
            sortedArtifacts = sortedArtifacts.findAll { includedModulesVal.contains(it.moduleName) }
        }

        // 3. Prepare State
        Set<String> processedKeys = ConcurrentHashMap.newKeySet()
        AtomicBoolean hasErrors = new AtomicBoolean(false)
        File tempFile = File.createTempFile("manifest-", ".tmp", outputFile.parentFile)

        // 4. Parallel Processing with ForkJoinPool (prevents Gradle worker starvation)
        ForkJoinPool customPool = null
        try {
            tempFile.withWriter(StandardCharsets.UTF_8.name()) { writer ->
                writer.write("[")

                def stream = sortedArtifacts.stream()
                if (hashesEnabled) stream = stream.parallel()

                def writeLock = new Object()
                AtomicBoolean firstEntry = new AtomicBoolean(true)

                Runnable processingTask = {
                    stream.forEach { item ->
                        // Heavy lifting (IO/Hashing) happens here
                        List<Map> entries = processItem(item, hashesEnabled, followSymlinksVal, failBrokenSymlinks, failHashError, processedKeys, errorLog, hasErrors)

                        if (!entries.isEmpty()) {
                            // Lightweight writing happens here sequentially
                            synchronized(writeLock) {
                                entries.each { entry ->
                                    if (!firstEntry.get()) writer.write(",")
                                    writer.write(JsonOutput.toJson(entry))
                                    firstEntry.set(false)
                                }
                            }
                        }
                    }
                }

                if (hashesEnabled) {
                    // Use a custom pool based on available processors
                    customPool = new ForkJoinPool(Runtime.runtime.availableProcessors())
                    customPool.submit(processingTask).get() // Wait for completion
                } else {
                    // Run on main thread if hashing is disabled (fast enough)
                    processingTask.run()
                }

                writer.write("]")
            }

            Files.move(tempFile.toPath(), outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING)

            if (hasErrors.get()) {
                logger.warn("[CI-Manifest] Completed with warnings/errors. Log: ${errorLog.absolutePath}")
            } else {
                logger.lifecycle("[CI-Manifest] Generated manifest: ${outputFile.name}")
            }

        } catch (Exception e) {
            Files.deleteIfExists(tempFile.toPath())
            throw e
        } finally {
            if (customPool != null) customPool.shutdown()
        }
    }

    List<Map> processItem(ArtifactData item, boolean hash, boolean followSymlinks, boolean failBrokenSymlinks, boolean failHashError, Set<String> processedKeys, File errorLog, AtomicBoolean hasErrors) {
        File file = item.file

        // --- Validation ---
        if (!file) return []

        boolean isSymlink = Files.isSymbolicLink(file.toPath())
        boolean exists = Files.exists(file.toPath())

        if (isSymlink && !exists) {
            def msg = "Broken symlink: ${file.absolutePath} (Module: ${item.moduleName})"
            logError(errorLog, msg)
            hasErrors.set(true)
            if (failBrokenSymlinks) throw new GradleException("[CI-Manifest] " + msg)
            return []
        }

        if (isSymlink && !followSymlinks) return []
        if (!exists || !file.isFile()) return []

        def results = []

        // --- Process Primary Artifact ---
        // Enhanced Key: Includes module and destName to prevent collisions
        String primaryKey = "PRIMARY|${item.moduleName}|${item.repoPath}|${item.destName}"

        if (processedKeys.add(primaryKey)) {
            def hashes = hash ? computeHashes(file, failHashError, errorLog, hasErrors) : [sha1: null, sha256: null, md5: null]

            results << [
                module_name: item.moduleName,
                type: item.type,
                name: item.destName,
                path: item.repoPath,
                sha1: hashes.sha1,
                sha256: hashes.sha256,
                md5: hashes.md5
            ]
        }

        // --- Process Detached Signature (.asc) ---
        File ascFile = new File(file.absolutePath + ".asc")

        if (Files.exists(ascFile.toPath())) {
            boolean ascIsSymlink = Files.isSymbolicLink(ascFile.toPath())

            if (!ascIsSymlink || followSymlinks) {
                String ascKey = "SIG|${item.moduleName}|${item.repoPath}.asc|${item.destName}.asc"

                if (processedKeys.add(ascKey)) {
                    if (Files.isReadable(ascFile.toPath())) {
                        def ascHashes = hash ? computeHashes(ascFile, failHashError, errorLog, hasErrors) : [sha1: null, sha256: null, md5: null]

                        results << [
                            module_name: item.moduleName,
                            type: "${item.type}.asc",
                            name: "${item.destName}.asc",
                            path: "${item.repoPath}.asc",
                            sha1: ascHashes.sha1,
                            sha256: ascHashes.sha256,
                            md5: ascHashes.md5
                        ]
                    }
                }
            }
        }

        return results
    }

    Map computeHashes(File file, boolean failOnError, File errorLog, AtomicBoolean hasErrors) {
        try {
            def md5 = MessageDigest.getInstance("MD5")
            def sha1 = MessageDigest.getInstance("SHA-1")
            def sha256 = MessageDigest.getInstance("SHA-256")

            // Use NIO InputStream for better consistency
            Files.newInputStream(file.toPath()).withCloseable { is ->
                byte[] buffer = new byte[BUFFER_SIZE]
                int read
                while ((read = is.read(buffer)) != -1) {
                    md5.update(buffer, 0, read)
                    sha1.update(buffer, 0, read)
                    sha256.update(buffer, 0, read)
                }
            }
            return [
                sha1: toHex(sha1.digest()),
                sha256: toHex(sha256.digest()),
                md5: toHex(md5.digest())
            ]
        } catch (Exception e) {
            def msg = "Hash failure [${file.name}]: ${e.message}"
            logError(errorLog, msg, e)
            hasErrors.set(true)

            if (failOnError) {
                throw new GradleException("[CI-Manifest] " + msg, e)
            }
            return [sha1: null, sha256: null, md5: null]
        }
    }

    void logError(File logFile, String message, Exception e = null) {
        // Safe mutex locking
        synchronized(logLock) {
            // Append mode with safe NIO
            try {
                // Ensure parent exists in case it's the first error
                if (!logFile.exists()) {
                    logFile.parentFile.mkdirs()
                    logFile.createNewFile()
                }
                
                logFile.withWriterAppend(StandardCharsets.UTF_8.name()) { w ->
                    w.writeLine("[${Instant.now()}] ${message}")
                    if (e) e.printStackTrace(new PrintWriter(w))
                    w.writeLine("-" * 80)
                }
            } catch (Exception ioEx) {
                System.err.println("CRITICAL: Failed to write to CI error log: ${ioEx.message}")
            }
        }
    }

    String toHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder()
        for (byte b : bytes) {
            sb.append(String.format("%02x", b))
        }
        return sb.toString()
    }
}

// ==============================================================================
// 3. WIRING
// ==============================================================================

gradle.rootProject {
    tasks.register("generateCiManifest", CiManifestTask) { t ->
        t.group = "reporting"
        t.description = "Generates a JSON manifest of all published artifacts"

        // Use layout API
        t.manifestFile.set(layout.buildDirectory.file("ci-artifacts-manifest.json"))
        t.failureLogFile.set(layout.buildDirectory.file("ci-manifest-failures.log"))

        // 1. Allow CLI Overrides via Project Properties
        def p = project
        def getProp = { String name, boolean defVal ->
            p.hasProperty(name) ? p.property(name).toBoolean() : defVal
        }

        def skipHash = p.hasProperty('ciInspector.skipHash') ? p.property('ciInspector.skipHash').toBoolean() : false
        t.shouldHash.set(!skipHash)

        // Policies
        t.followSymlinks.set(getProp('ciManifest.followSymlinks', false))
        t.failOnBrokenSymlinks.set(getProp('ciManifest.failOnBrokenSymlinks', true))
        t.failOnHashError.set(getProp('ciManifest.failOnHash', true))
    }
}

// Ensure we wait for ALL projects to finish evaluation
gradle.projectsEvaluated {
    allprojects { project ->
        def publishing = project.extensions.findByType(PublishingExtension)
        if (!publishing) return

        // Locate the root task
        def rootTask = project.rootProject.tasks.findByName("generateCiManifest")
        if (!rootTask) return

        def localArtifacts = []
        collectArtifacts(project, publishing, localArtifacts)

        if (!localArtifacts.isEmpty()) {
            rootTask.configure { t ->
                localArtifacts.each { artifactData -> t.addArtifact(artifactData) }
            }

            // Fix: Use mustRunAfter to avoid triggering manifest task unnecessarily
            rootTask.mustRunAfter(project.tasks.withType(PublishToMavenRepository))
            rootTask.mustRunAfter(project.tasks.withType(PublishToIvyRepository))
        }
    }
}

// Helper: Collects artifact data without resolving files eagerly
void collectArtifacts(Project project, PublishingExtension publishing, List<ArtifactData> list) {
    def projectPath = project.path

    publishing.publications.all { publication ->
        def coords = [:]
        def isMaven = (publication instanceof MavenPublication)
        def isIvy = (publication instanceof IvyPublication)

        if (isMaven) {
            if (!publication.groupId || !publication.artifactId || !publication.version) return
            coords = [g: publication.groupId, a: publication.artifactId, v: publication.version]
        } else if (isIvy) {
            if (!publication.organisation || !publication.module || !publication.revision) return
            coords = [o: publication.organisation, m: publication.module, r: publication.revision]
        }

        def getRepoPath = { name ->
            if (isMaven) return "${coords.g.replace('.','/')}/${coords.a}/${coords.v}/${name}"
            else return "${coords.o}/${coords.m}/${coords.r}/${name}"
        }

        def track = { Object rawFile, String name, String type, Object builtBy = null ->
            File f = resolveToFile(rawFile)
            if (f != null) {
                def d = new ArtifactData()
                d.file = f
                d.destName = name
                d.repoPath = getRepoPath(name)
                d.type = type
                d.moduleName = projectPath
                d.builtBy = builtBy
                list.add(d)
            }
        }

        // A. Artifacts
        publication.artifacts.each { artifact ->
            def ext = artifact.extension ?: "jar"
            def classifier = artifact.classifier ?: ""
            def suffix = classifier ? "-${classifier}" : ""
            def destName = isMaven
                ? "${coords.a}-${coords.v}${suffix}.${ext}"
                : "${coords.m}-${coords.r}${suffix}.${ext}"
            track(artifact.file, destName, ext, artifact.buildDependencies)
        }

        // B. Metadata (Maven)
        if (isMaven) {
            def pomName = "${coords.a}-${coords.v}.pom"
            def pomTask = project.tasks.findByName("generatePomFileFor${publication.name.capitalize()}Publication")
            if (pomTask) track(pomTask.outputs.files.singleFile, pomName, "pom", pomTask)

            def moduleName = "${coords.a}-${coords.v}.module"
            def metaTaskName = "generateMetadataFileFor${publication.name.capitalize()}Publication"
            if (project.tasks.names.contains(metaTaskName)) {
                def metaTask = project.tasks.findByName(metaTaskName)
                if (metaTask && metaTask.enabled) {
                    track(metaTask.outputs.files.singleFile, moduleName, "module", metaTask)
                }
            }
        }

        // C. Metadata (Ivy)
        if (isIvy) {
            def ivyName = "ivy-${coords.r}.xml"
            def ivyTask = project.tasks.findByName("generateDescriptorFileFor${publication.name.capitalize()}Publication")
            if (ivyTask) track(ivyTask.outputs.files.singleFile, ivyName, "ivy", ivyTask)
        }
    }
}

// Gradle 5+ Safe Helper
File resolveToFile(Object raw) {
    if (raw == null) return null
    if (raw instanceof File) return raw
    if (raw instanceof org.gradle.api.provider.Provider) {
        try {
            def v = raw.getOrNull()
            if (v instanceof org.gradle.api.file.RegularFile) return v.asFile
            if (v instanceof File) return v
        } catch (Exception e) { return null }
    }
    return null
}